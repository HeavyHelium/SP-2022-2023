# For theory

14, 15, 16, 17, 18 questions
11 евентуално

## Всички начини за създаване на процес -- fork() е единственият начин. 

Единственият начин за създаване на нов процес от ядрото е, когато съществуващ процес извика примитива ```fork()```. Отбелязвам, че ако не съществува процес, тогава се пуска ```init```.   

Когато се създаде процес, се поддържа дърво на наследяване.

```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

```fork``` създава нов процес;    
новосъздаденият процес използва *заедно с родителя си* **програмния сегмент**, а ***сегмент данни и стек се копират*** от родителя в момента на създаването, т.е. детето наследява всичките променливи, отворени файлове и изобщо всички данни, съществуващи в родителя, а след това всеки процес се развива самостоятелно.   
Стойността, която се връща при родителя, е pid-а на новосъздадения процес-дете. Стойността, която получава процесът дете, е 0.
При провал връща -1.

Поддържа се дърво на наследяване. 
Има системни извиквания, така че всеки процес знае своя pid и pid-a на родителя си. Такива са ```getpid``` и ```getppid```.

```init``` се пуска, когато ядрото няма нито един процес.


## fork и wait

* Опишете функционалността на системни извиквания ```fork(2)``` и ```wait(2)```. Кога процес преминава в състояние ```wait(2)```. Кога процес преминава в състояние zombie и как излиза от това състояние?

```wait```
Използва се за изчакване на процес-дете, като ако има няколко деца, wait чака първото, което завърши, т.е. родителският процес бива блокиран, докато първото дете не завърши своето изпълнение.
Връща pid-а на първтото завършило дете;

```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);
```
Възможно е, когато родителят не изчака некое свое дете, то да се превърне в зомби процес, т.е. да остане запис за него в таблицата с процесите, след като то е приключило своето действие.


## Системни извиквания при работа с анонимна тръба

Използваме ```read(), write, close, pipe.```
Биха завършили с грешка тези системни извиквания, които очакват подадения обект да бъде интерпретиран като масив от байтове, т.е.  ```lseek(), ftruncate().```

* Функционалност

```c
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fd, off_t offset, int flag);
// Връща новата текуща позиция при успех, -1 при грешка.
```
lseek позволява да се премести файловият указател на текущата позиция на произволна позиция във файла или след края му без I/O операция.

Новото значение на текущата позиция във файла се изчислява в зависимост от flag-а(SEEK_SET, SEEK_CUR, SEEK_END). 

```c
 int ftruncate(int fd, off_t length);
```
При него файлът, който се сочи от файловия дескприптор, се свива или разширява до подадения размер. Ако файлът е по-обемен от подадения размер, тогава се губят данни и размерът става точно дадения. Ако е по-малък, се добавят нулеви байтове, докато не стане точно толкова голям. При ftruncate, файлът трябва да бъде отворен за писане.
При грешка връща -1, иначе 0.


## sem_post, sem_wait, sem_trywait

* Функционалност

```c
#include <semaphore.h>

int sem_post(sem_t *sem);
```
Инкрементира брояча на семафора, който се сочи от sem. Ако след това тази стойност е положителна, то друг процес или нишка, блокирана от sem_wait извикване, ще бъде събуден. 
При провал връща 1, иначе 0. 

```c
 int sem_wait(sem_t *sem);
```
Декрементира брояча на семафора, който се сочи от sem. 
Ако стойността на брояча е положителна, то декрементирането се случва и функцията прекратява своето действие. Ако след декрементиране тя е 0, тогава процесът се приспива докато стойността не бъде инкрементирана до положително число.  

При провал връща -1, иначе 0.

```c
  int sem_trywait(sem_t *sem);
```

Същото като sem_wait, само че ако декрементирането не може да се извърши веднага, връща грешка ```EAGAIN```, вместо да блокира.

* Грешки

error ```EINTR```\:  
sem_post не може  
***sem_wait може*** \: ако през pipe процес е стоял дълго време  
sem_trywait не, не спира процеса

error ```EAGAIN```\:   когато правим асинхронно извикване  
sem_post не може, няма опция за присписаве,   
sem_wait не може  
***само в sem_try_wait***

## open и link

```c
   #include <unistd.h>

   int open(const char *pathname, int flags, mode_t mode);
   int link(const char *oldpath, const char *newpath);
   // link връща 0 при успех и -1 при провал
```
* Функционалност
```open``` създава връзка между процеса и указания файл. Тази връзка се идентифицира с файловия десктриптор, върнат от ```open```. Като файлът може да бъде отворен в различни режими, който се определят от mode.  

```link``` създава нова твърда връзка към съществуващ файл, като добавя нов запис за файла в каталог. Също така в индексния дескритор за файла се увеличава с 1 броят на твърдите връзки за файла. 

да се опише функционалността и сравнение

link създава нова твърда връзка

***Прилики\:***
Създадения файлов дескриптор създава нова(играе ролята на) твърда връзка
Ако няма твърди връзки, файлът се изтрива.
Като цяло си приличат по механизма. Например файл е затворен, когато няма дескриптори към него. Аналогично файл се изтрива, когато няма твърди връзки към него.

## open, pipe и accept
```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

```  
```accept``` се използва за установяване на междупроцесна връзка. Взема първата връзка от опашката с чакащи връзки за слушащия сокет sockfd, създава нов сокет и връща нов файлов дескрqиптор, асоцииран с този сокет. Новият сокет не е в слушащо състояние. 

Аргументи\:
* ```sockfd``` е файлов дескриптор към сокет, който е бил създаден чрез ```socket``` и е бил вързан за локален адрес чрез ```bind``` и слуша за нови връзки, след като върху него е бил приложен ```listen```.

* ```addr``` е указател към обект, който има поле за адреса на сокета, към който ще се установи връзка, като форматът на този обект се определя от адресното семейство на сокета(запълва се). 

* ```addlen``` value-result аргумент, означаващ размера на адреса

създават файлов дескриптор и с read и write, close

Приличат си по това, че при тях се създават връзки. Различават се по типа на създадените връзки\:

open\: процес - файл

връзка м/у два процеса\:

при pipe връзката е м/у родител и негови наследници, т.е. каналът може да се използва само от процеса, който го е създал, и от създадени от него(в последствие) процеси-деца, които получават копия на отворените файлови дескриптори, т.е. връзката е анонимна

accept - нероднинска връзка между процеси


## Споделена памет\: ```shm_overview, shm_open, ftruncate, mmap```

### shm_open, ftruncate, mmap

```c
int shm_open(const char *name, int oflag, mode_t mode);

```

Създава и отваря нов или отваря вече съществуващ обект споделена памет. Такъв обект може да бъде използван от нероднински процеси, за да преглеждат една и съща част от споделената памет. 
Като структура е аналогичен на open().
Връща файлов дескритпор към споделената памет.
Нов обект споделена памет отначало е с нулев размер. Чрез ftruncate можем да укажем колко голям да бъде. 

```c
void* mmap(void* addr, 
           size_t length, 
           int prot, 
           int flags,
           int fd, 
           off_t offset);
```

Чрез mmap казваме, че ще ползваме споделената памет, файловият дескриптор е към споделена памет или към обикновен фаил. Ползваме го като обикновен масив от байтове, зарежда се в RAM-та. Връща указател към този масив. 
След като е затворен файловият дескриптор, споделената памет може да се използва, т.е. тя не се инвалидира.

Споделената памет може само с mmap да я видим, read и write не работят в/у него. Но четенето и писането става с обикновена адресация. 

Ползва се при exec.  
еxec прави mmap на кода на програмата;
copy-on-demand



## signal, kill, pause, alarm

man those

## socket, connect, bind, listen

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
// creates an endpoint
```

Създава сокет и връща файлов дескриптор към него, който е първият във възходящ ред незает файлов дескриптор. 

```domain``` указва коя фамилия протоколи ще се използва за комуникация  
```type``` указва типа на сокета(дали е двупосочен и т.н.)  
```protocol``` указва конкретен протокол, който да бъде използва с този сокет  сс

```c
 int connect(int sockfd, const struct sockaddr *addr,
             socklen_t addrlen);
```

Свързва сокета, сочен от файловия дескриптор с подадения адрес.

```c
 int bind(int sockfd, const struct sockaddr *addr,
          socklen_t addrlen);

```
When a socket is created with socket(2), it exists in a name space (ad‐
dress family) but has no address assigned to it.   bind()  assigns  the
address  specified  by  addr  to the socket referred to by the file de‐
scriptor sockfd.  addrlen specifies the size, in bytes, of the  address
structure  pointed to by addr.  Traditionally, this operation is called
“assigning a name to a socket”.

```c
int listen(int sockfd, int backlog);
```  
listen()  marks  the  socket referred to by sockfd as a passive socket,
that is, as a socket that will be used to  accept  incoming  connection
requests using accept(2). 