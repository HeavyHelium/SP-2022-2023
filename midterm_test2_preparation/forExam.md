# For theory

14, 15, 16, 17, 18 questions
11 евентуално

## Всички начини за създаване на процес -- fork() е единственият начин. 

Единственият начин за създаване на нов процес от ядрото е, когато съществуващ процес извика примитива ```fork()```. Отбелязвам, че ако не съществува процес, тогава се пуска ```init```.   

Когато се създаде процес, се поддържа дърво на наследяване.

```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

```fork``` създава нов процес;    
новосъздаденият процес използва *заедно с родителя си* **програмния сегмент**, а ***сегмент данни и стек се копират*** от родителя в момента на създаването, т.е. детето наследява всичките променливи, отворени файлове и изобщо всички данни, съществуващи в родителя, а след това всеки процес се развива самостоятелно.   
Стойността, която се връща при родителя, е pid-а на новосъздадения процес-дете. Стойността, която получава процесът дете, е 0.
При провал връща -1.

Поддържа се дърво на наследяване. 
Има системни извиквания, така че всеки процес знае своя pid и pid-a на родителя си. Такива са ```getpid``` и ```getppid```.

```init``` се пуска, когато ядрото няма нито един процес.


## ```fork и wait```

* Опишете функционалността на системни извиквания ```fork(2)``` и ```wait(2)```. Кога процес преминава в състояние ```wait(2)```. Кога процес преминава в състояние zombie и как излиза от това състояние?

```wait```
Използва се за изчакване на процес-дете, като ако има няколко деца, wait чака първото, което завърши, т.е. родителският процес бива блокиран, докато първото дете не завърши своето изпълнение.
Връща pid-а на първтото завършило дете;

```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);
```
Възможно е, когато родителят не изчака некое свое дете, то да се превърне в зомби процес, т.е. да остане запис за него в таблицата с процесите, след като то е приключило своето действие.
След като родителя терминира, такова дете бива осиновено от ```init``` процеса и записът за него се чисти.


## Системни извиквания при работа с анонимна тръба(т.е. pipe)

Използваме ```read, write, close, pipe.```
Биха завършили с грешка тези системни извиквания, които очакват подадения обект да бъде интерпретиран като масив от байтове, т.е.  ```lseek(), ftruncate()```, докато тръбата представлява поток от данни. Не можем да променим размера на тръбата.

Т.е. ```lseek``` и ```ftruncate``` работят за файлови дескриптори към обикновени файлове, т.е. файлови дескриптори, създадени с ```open```. Ако се викнат върху тръба или сокет, се връща грешка ESPIPE/EINVAL.

* Функционалност

```c
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fd, off_t offset, int flag);
// Връща новата текуща позиция при успех, -1 при грешка.
```
lseek позволява да се премести файловият указател от текущата позиция на произволна позиция във файла или след края му без I/O операция.

Новото значение на текущата позиция във файла се изчислява в зависимост от flag-а(SEEK_SET, SEEK_CUR, SEEK_END). 



```c
 int ftruncate(int fd, off_t length);
```
При него файлът, който се сочи от файловия дескприптор, се свива или разширява до подадения размер. Ако файлът е по-обемен от подадения размер, тогава се губят данни и размерът става точно дадения. Ако е по-малък, се добавят нулеви байтове, докато не стане точно толкова голям. При ftruncate, файлът трябва да бъде отворен за писане.
При провал връща -1, иначе 0.





```Note: ```The SEEK_END, SEEK_CUR or,the SEEK_SET are merely the Macro Expansions with values of 2,1 and 0 respectively.

## ```sem_post, sem_wait, sem_trywait```

* Функционалност

```c
#include <semaphore.h>

int sem_post(sem_t *sem);
```
Инкрементира брояча на семафора, който се сочи от sem. Ако след това тази стойност е положителна, то друг процес или нишка, блокирана от sem_wait извикване, ще бъде събуден. 
При провал връща -1, иначе 0. 

```c
 int sem_wait(sem_t *sem);
```
Декрементира брояча на семафора, който се сочи от sem. 
Ако стойността на брояча е положителна, то декрементирането се случва и функцията прекратява своето действие. Ако тя е 0(initially, of course), тогава блокира, докато стойността не бъде инкрементирана до положително число, т.е. да може да се случи декрементирането, или не се получи сигнал, който да прекъсне изпълнението(ако например процесът/нишката твърде много време е чакал).

При провал връща -1, иначе 0.

```c
  int sem_trywait(sem_t *sem);
```

Същото като sem_wait, само че ако декрементирането не може да се извърши веднага, връща грешка ```EAGAIN```, вместо да блокира.

* Грешки

error ```EINTR```\:  
sem_post не може , само тези, който приспиват процес могат  
***само sem_wait може*** \: ако през pipe процес е стоял дълго време  
sem_trywait не, не спира процеса

error ```EAGAIN```\:   когато правим асинхронно извикване    
***само в sem_try_wait***

## ```open и link```

```c
   #include <unistd.h>

   int open(const char *pathname, int flags, mode_t mode);
   int link(const char *oldpath, const char *newpath);
   // link връща 0 при успех и -1 при провал
```
* Функционалност  

```open``` създава връзка(комуникационен канал) между процеса и указания файл. Тази връзка се идентифицира с файловия десктриптор, върнат от ```open```. Като файлът може да бъде отворен в различни режими, които се определят от mode.  

```link``` създава нова твърда връзка към съществуващ файл, като добавя нов запис за файла в каталог. Това означава, че файлът може да бъде използван и с двете имена, тъй като твърдата връзка е референция към inode-а на файла.

***Прилики\:***
Т.е. и двете системни извиквания създават нови указатели към съществуващ файл(в случая на open, може първо да се създаде файла).  

Създадения файлов дескриптор създава нова(играе ролята на) твърда връзка.

Ако няма твърди връзки, файлът се изтрива.  
Като цяло си приличат по механизма. Например файл е затворен, когато няма дескриптори към него. Аналогично файл се изтрива, когато няма твърди връзки към него.

***Разлики\:***
```open``` връща файлов дескриптор(споделен обект)(е, връща и -1 при провал де), а ```link``` връща -1 при провал и 0 при успех.   
Друга разлика е, че създадената от ```link``` твърда връзка остава постоянно на файловата система(до изтриването й с ```unlink```), докато файловите дескриптори биват унищожени след края на процеса, дори й да не е явно извикан ```close``` за тях.
  

## ```open, pipe и accept```
```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

```  
```accept``` се използва за установяване на двустранна междупроцесна връзка(по-точно за приемане на запитване за изграждане на връзка). Взема първата заявка за връзка от опашката с чакащи за изграждане на връзка процеси за слушащия сокет(sockfd), създава нов свързан сокет и връща нов файлов дескриптор, асоцииран с този сокет. Новият сокет не е в слушащо състояние.


Аргументи\:
* ```sockfd``` е файлов дескриптор към сокет, който е бил създаден чрез ```socket``` и е бил вързан за локален адрес чрез ```bind``` и слуша за нови връзки, след като върху него е бил приложен ```listen```

* ```addr``` е указател към обект, който има поле за адреса на сокета, към който ще се установи връзка, като форматът на този обект се определя от адресното семейство на сокета(запълва се)

* ```addlen``` value-result аргумент, означаващ размера на адреса

***Прилики*** \:

Създават файлов дескриптор, използваме с read и write, close.

Приличат си и по това, че при тях се създават връзки. Различават се по типа на създадените връзки\:

```open``` \: комуникационен канал за обмен на данни м/у  ***процес и файл***

***връзка м/у два процеса*** \:

add a word or two about the signatures;

при pipe връзката е м/у родител и негови наследници, т.е. каналът може да се използва само от процеса, който го е създал, и от създадени от него(в последствие) процеси-деца, които получават копия на отворените файлови дескриптори, т.е. връзката е анонимна

accept - нероднинска връзка процеси, която само те и евентуално техни наследници виждат.


## Споделена памет\: ```shm_overview, shm_open, ftruncate, mmap```

### ```shm_open, ftruncate, mmap```

```c
int shm_open(const char *name, int oflag, mode_t mode);

```

Създава и отваря нов или отваря вече съществуващ обект споделена памет. Такъв обект може да бъде използван от нероднински процеси, за да преглеждат една и съща част от споделената памет. 
Aналогичен на open().

Мод-а обаче ***няма*** опция само за писане, т.е. **O_WRONLY**, няма **O_APPEND** и ***има*** **O_EXCL**(ако O_CREAT е бил добавен и има преди това споделен обект със същото име, се връща грешка)

Връща файлов дескритпор към споделената памет(най-малкия незает дотогава).
Нов обект споделена памет отначало е с нулев размер. Чрез ftruncate можем да укажем колко голям да бъде. 

```c
void* mmap(void* addr, 
           size_t length, 
           int prot, 
           int flags,
           int fd, 
           off_t offset);
```

```addr``` е хинт към ОС къде да се позиционира споделената памет.
```prot``` е типа защита(**PROT_NONE, PROT_WRITE, PROT_READ, PROT_EXEC**)
Чрез mmap казваме, че ще ползваме споделената памет, файловият дескриптор е към споделена памет или към обикновен файл, тоест към обекта, който мапваме. Map-ваме ```length``` байта, почвайки от ```offset```.


 Ползваме го като обикновен масив от байтове, зарежда се в RAM-та. ***Връща указател към този масив.***

След като е затворен файловият дескриптор, споделената памет може да се използва, т.е. тя не се инвалидира.

Споделената памет може само с mmap да я видим, read и write не работят в/у него. Но четенето и писането става с обикновена адресация. 

Ползва се при exec.  
еxec прави mmap на кода на програмата;
copy-on-demand



## ```signal, kill, pause, alarm```

man those

## ```socket, connect, bind, listen```

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
// creates an endpoint
```

Създава сокет и връща файлов дескриптор към него, който е първият във възходящ ред незает файлов дескриптор. 

```domain``` указва коя фамилия протоколи ще се използва за комуникация  
```type``` указва типа на сокета(дали е двупосочен и т.н.)  
```protocol``` указва конкретен протокол, който да бъде използва с този сокет  сс

```c
 int connect(int sockfd, const struct sockaddr *addr,
             socklen_t addrlen);
```

Свързва сокета, сочен от файловия дескриптор с подадения адрес.

```c
 int bind(int sockfd, const struct sockaddr *addr,
          socklen_t addrlen);

```
When a socket is created with socket(2), it exists in a name space (ad‐
dress family) but has no address assigned to it.   bind()  assigns  the
address  specified  by  addr  to the socket referred to by the file de‐
scriptor sockfd.  addrlen specifies the size, in bytes, of the  address
structure  pointed to by addr.  Traditionally, this operation is called
“assigning a name to a socket”.

```c
int listen(int sockfd, int backlog);
```  
listen()  marks  the  socket referred to by sockfd as a passive socket,
that is, as a socket that will be used to  accept  incoming  connection
requests using accept(2). 