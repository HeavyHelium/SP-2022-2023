# For theory

14, 15, 16, 17, 18 questions
11 евентуално

## Всички начини за създаване на процес -- fork() е единственият начин. 

Единственият начин за създаване на нов процес от ядрото е, когато съществуващ процес извика примитива ```fork()```. Отбелязвам, че ако не съществува процес, тогава се пуска ```init```.   

Когато се създаде процес, се поддържа дърво на наследяване.

```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

```fork``` създава нов процес;    
новосъздаденият процес използва *заедно с родителя си* **програмния сегмент**, а ***сегмент данни и стек се копират*** от родителя в момента на създаването, т.е. детето наследява всичките променливи, отворени файлове и изобщо всички данни, съществуващи в родителя, а след това всеки процес се развива самостоятелно.   
Стойността, която се връща при родителя, е pid-а на новосъздадения процес-дете. Стойността, която получава процесът дете, е 0.
При провал връща -1.

Поддържа се дърво на наследяване. 
Има системни извиквания, така че всеки процес знае своя pid и pid-a на родителя си. Такива са ```getpid``` и ```getppid```.

```init``` се пуска, когато ядрото няма нито един процес.


## fork и wait

* Опишете функционалността на системни извиквания ```fork(2)``` и ```wait(2)```. Кога процес преминава в състояние ```wait(2)```. Кога процес преминава в състояние zombie и как излиза от това състояние?

```wait```
Използва се за изчакване на процес-дете, като ако има няколко деца, wait чака първото, което завърши, т.е. родителският процес бива блокиран, докато първото дете не завърши своето изпълнение.
Връща pid-а на първтото завършило дете;

```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);
```
Възможно е, когато родителят не изчака некое свое дете, то да се превърне в зомби процес, т.е. да остане запис за него в таблицата с процесите, след като то е приключило своето действие.


## Системни извиквания при работа с анонимна тръба

Използваме ```read(), write, close, pipe.```
Биха завършили с грешка тези системни извиквания, които очакват подадения обект да бъде интерпретиран като масив от байтове, т.е.  ```lseek(), ftruncate().```

* Функционалност
```c
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fd, off_t offset, int flag);
// Връща новата текуща позиция при успех, -1 при грешка.
```
lseek позволява да се премести файловият указател на текущата позиция на произволна позиция във файла или след края му без I/O операция.

Новото значение на текущата позиция във файла се изчислява в зависимост от flag-а(SEEK_SET, SEEK_CUR, SEEK_END). 

```c
 int ftruncate(int fd, off_t length);
```
При него файлът, който се сочи от файловия дескприптор, се свива или разширява до подадения размер. Ако файлът е по-обемен от подадения размер, тогава се губят данните и размерът става точно дадения. Ако е по-малък, се добавят нулеви байтове, докато не стане точно толкова голям. При ftruncate, файлът трябва да бъде отворен за писане.
При грешка връща -1, иначе 0.


## sem_post, sem_wait, sem_trywait

* Функционалност

```c
#include <semaphore.h>

int sem_post(sem_t *sem);
```
Инкрементира брояча на семафора, който се сочи от sem. Ако след това тази стойност е положителна, то друг процес или нишка, блокирана от sem_wait извикване, ще бъде събуден. 
При провал връща 1, иначе 0. 

```c
 int sem_wait(sem_t *sem);
```
Декрементира брояча на семафора, който се сочи от sem. 
Ако стойността на брояча е положителна, то декрементирането се случва и и функцията прекратява своето действие. Ако след декрементиране тя е 0, тогава процесът се приспива докато стойността не бъде инкрементирана до положително число.  

При провал връща -1, иначе 0.

```c
  int sem_trywait(sem_t *sem);
```

Същото като sem_wait, само че ако декрементирането не може да се извърши веднага, връща грешка ```EAGAIN```, вместо да блокира.

* Грешки

error ```EINTR```\:
sem_post не може
***sem_wait може***\: ако през pipe процес е стоял дълго време
sem_trywait не, не спира процеса

error ```EAGAIN```\: когато правим асинхронно извикване
sem_post не може, няма опция за присписаве, 
sem_wait не може
***само в sem_try_wait***

## open и link

```c
   #include <unistd.h>

   int open(const char *pathname, int flags, mode_t mode);
   int link(const char *oldpath, const char *newpath);
   // link връща 0 при успех и -1 при провал
```
* Функционалност
```open``` създава връзка между процеса и указания файл. Тази връзка се идентифицира с файловия десктриптор, върнат от ```open```. Като файлът може да бъде отворен в различни режими, който се определят от mode.  

```link``` създава нова твърда връзка към съществуващ файл, като добавя нов запис за файла в каталог. Също така в индексния дескритор за файла се увеличава с 1 броят на твърдите връзки за файла. 

да се опише функционалността и сравнение

link създава нова твърда връзка

***Прилики\:***
Създадения файлов дескриптор създава нова(играе ролята на) твърда връзка
Ако няма твърди връзки, файлът се изтрива.
Като цяло си приличат по механизма. Например файлът се затваря, когато няма дескриптори към него. Аналогично файл се изтрива, когато няма твърди връзки към него.

## open, pipe и accept
създават файлов дескриптор и с read и write, close

Приличат си по това, че при тях се създават връзки. Различават се по типа на създадените връзки\:

функционалността

open\: процес - файл

връзка м/у два процеса\:

при pipe връзката е м/у родител и негови наследници, т.е. каналът може да се използва само от процеса, който го е създал, и от създадени от него(в последствие) процеси-деца, които получават копия на отворените файлови дескриптори 

accept - нероднинска връзка, която самo те я виждат, евентуално и наследници

pipe анонимна връзка

## Споделена памет\: ```shm_overview, shm_open, ftruncate, mmap```

### shm_open, ftruncate, mmap

може нещо от темата за споделена памет\: mmap()

shmopen(за споделена памет), ftruncate(казва колко голяма да бъде), mmap(казваме, че ще я ползваме, файловият дескриптор е към споделена памет или към обикновен фаил, позлваме го като обикновен масив от байтове, зарежда се в RAM-та), връща указател към този масив

споделената памет може само с mmap да я видим, read и write не работят в/у него. Но четенето и писането става с обикновена адресация. 
Ползва се при exec.

еxec прави mmap на кода на програмата;
copy-on-demand
